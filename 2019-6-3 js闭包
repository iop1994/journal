在函数内调用外部变量（引用了自由变量的函数），高阶函数？？？
声明新函数时，将其赋值给变量，都会存储函数定义和闭包（作用域）。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。
闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。

在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。

当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。

JavaScript的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止  
变量寻找和作用域以及函数定义时的执行上下文相关联

例子
function a () {   
    function b() {      
      var bbb = 234;      
      console.log(aaa)   
    }   
    var aaa = 123;  
 return b;
}
var glob = 100;
var demo = a();
demo();

当函数执行完毕，执行上下文被销毁
  a执行引起b的定义，b定义的时候直接继承a的劳动成果，把a的作用域链全部加持到自己身上。
  当执行return b ； 的时候， b函数带着他身上的作用域链一起被返回了出去，然后a执行结束， 
  这个时候 a.[[scope]] [0] 指向的  aAO，就会被销毁，就相当于是把a.[[scope]] [0] 连接 的 aAO的那根线给剪短了。
  但是整个b函数全部返回出去赋值给了demo， demo就变成了函数，demo的作用域链就是b函数的作用域链，
  而b的作用域链又是继承的 a函数的作用域链，里面包含了所有在a函数里面定义的变量 。
  
  所以demo 函数就可以对自己的作用域链里面的值为所欲为。而且当a再次执行的时候，他创建的是一个新的AO对象，他也管不了上一次创建的变量。
  所以 demo函数的作用域里面的变量就成为了demo的私有变量，除了他自己，谁用调用不了。

  函数a  return b; 返回的是该函数的作用域链
